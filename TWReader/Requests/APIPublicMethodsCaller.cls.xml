<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25">
<Class name="TWReader.Requests.APIPublicMethodsCaller">
<Description>
This class is actually API wrapper (with some properties disabled) for TW API.</Description>
<Super>%RegisteredObject</Super>
<TimeCreated>63470,45984.335131</TimeCreated>

<UDLText name="T">
<Content><![CDATA[
// Parameter MaxEntityQueryCount As %Integer = 100;

]]></Content>
</UDLText>

<Parameter name="ApiServer">
<Default>api.twitter.com</Default>
</Parameter>

<Parameter name="ApiSearchUrl">
<Default>1.1/search/tweets.json</Default>
</Parameter>

<Parameter name="ConsumerKey">
<Default>WpT9B0QNyGo0rMP3UxJfKA</Default>
</Parameter>

<Parameter name="ConsumerSecret">
<Default>W4LEDTYhUYZZHkagJTsjyN67DolAjZ3SuR1TvqU80iI</Default>
</Parameter>

<Parameter name="AuthToken">
<Default>1885599715-fiwI4aLgQzdbgYhjHT7whqPC8xmTpr4mNjlskpg</Default>
</Parameter>

<Parameter name="AuthTokenSecret">
<Default>qpaGPTKL7gsU3a3beEsD3UFHiTW0WCt7p28PASBy6Ww</Default>
</Parameter>

<Parameter name="SignatureMethod">
<Default>HMAC-SHA1</Default>
</Parameter>

<Parameter name="AuthVersion">
<Default>1.0</Default>
</Parameter>

<Parameter name="AuthPrefix">
<Default>OAuth </Default>
</Parameter>

<Method name="TweetsSearch">
<FormalSpec><![CDATA[&responseData:%String(MAXLEN=1000000),listparams:%List]]></FormalSpec>
<ReturnType>%ListOfObjects</ReturnType>
<Implementation><![CDATA[
	#dim a as %ArrayOfDataTypes = ##class(%ArrayOfDataTypes).%New()
	do a.SetAt($li(listparams, 1), "q")
	do a.SetAt("recent", "result_type")
	do a.SetAt($li(listparams, 2), "count")
	do:($li(listparams, 2)="") a.SetAt(15, "count")
	//do ..AddParameter(a, "since_id", sinceId)
	//do ..AddParameter(a, "until", ..DateToString(until))
	
	#dim url = "https://" _ ..#ApiServer _ "/" _ ..#ApiSearchUrl
	#dim authHeader as %String = ..GetAuthHeader("get", url, a)

	#dim status as %Status = ##class(TWReader.Requests.RequestSender).SendHttpRequest(..#ApiServer, ..#ApiSearchUrl, .responseData, a, 1, authHeader)
	
	q responseData
]]></Implementation>
</Method>

<Method name="GetAuthHeader">
<FormalSpec>action:%String,url:%String,parameters:%ArrayOfDataTypes=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	#dim nonce as %String = $system.Util.CreateGUID()
	#dim time as %String = $ztimestamp	
	#dim unixTime as %Integer = ##class(Util.Misc).ConvertHorologToUnixTime(+time, $normalize(+$piece(time, ",", 2), -1))
	#dim h as %ArrayOfDataTypes = ##class(%ArrayOfDataTypes).%New()
	do h.SetAt(..#ConsumerKey, "oauth_consumer_key")
	do h.SetAt(nonce, "oauth_nonce")
	do h.SetAt(..#SignatureMethod, "oauth_signature_method")
	do h.SetAt(unixTime, "oauth_timestamp")
	do h.SetAt(..#AuthToken, "oauth_token")
	do h.SetAt(..#AuthVersion, "oauth_version")
	#dim a as %ArrayOfDataTypes = h.%ConstructClone(1)
	do ..AppendArray(a, parameters)
	set query = ..RequestArrayToQueryString(action, url, a)
	write "query="_query ,!
	#dim signatureBase as %String = $system.Encryption.HMACSHA1(query,##class(Util.Misc).UrlEncode(..#ConsumerSecret)_"&"_##class(Util.Misc).UrlEncode(..#AuthTokenSecret))
	//#dim signatureBase as %String = ..CreateSignature(query, ..SigningKey)
	#dim signature as %String = $system.Encryption.Base64Encode(signatureBase)
	do h.SetAt(signature, "oauth_signature")
	quit ..BuildAuthHeader(h)
]]></Implementation>
</Method>

<Method name="BuildAuthHeader">
<ClassMethod>1</ClassMethod>
<FormalSpec>parameters:%ArrayOfDataTypes</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	#dim encodedArray as %ArrayOfDataTypes = ..PercentEncodeArray(parameters)
	#dim dst as %String = ""
	#dim k as %String = ""
	set k = ""
	while (1)
	{
		#dim v as %String = encodedArray.GetNext(.k)
		quit:k=""
		do ..AppendAuthHeaderParameter(.dst, k, v)
	}
	set dst = ..#AuthPrefix _ dst
	quit dst
]]></Implementation>
</Method>

<Method name="AppendArray">
<ClassMethod>1</ClassMethod>
<FormalSpec>a:%ArrayOfDataTypes,b:%ArrayOfDataTypes</FormalSpec>
<Implementation><![CDATA[
	if (b '= "")
	{
		#dim k as %String = ""
		set k = ""
		while (1)
		{
			#dim v as %String = b.GetNext(.k)
			quit:k=""
			do a.SetAt(v, k)
		}
	}
]]></Implementation>
</Method>

<Method name="RequestArrayToQueryString">
<ClassMethod>1</ClassMethod>
<FormalSpec>action:%String,url:%String,parameters:%ArrayOfDataTypes</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	#dim queryString as %String = ""
	set action = $zconvert(action, "U")
	do ..AppendQueryParameter(.queryString, action, "", 1)
	do ..AppendQueryParameter(.queryString, ##class(Util.Misc).UrlEncode(url), "", 1)
	write "url = "_url ,!
	write "urlEncode = "_##class(Util.Misc).UrlEncode(url) ,!
	#dim q as %String = ..ArrayToQueryString(parameters)
	set q = ##class(Util.Misc).UrlEncode(q)
	if (q '= "")
	{
		set queryString = queryString _ "&" _ q
	}
	quit queryString
]]></Implementation>
</Method>

<Method name="ArrayToQueryString">
<ClassMethod>1</ClassMethod>
<FormalSpec>a:%ArrayOfDataTypes</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	#dim queryString as %String = ""
	// Build sorted array of encoded key/value pairs:
	#dim encodedArray as %ArrayOfDataTypes = ..PercentEncodeArray(a)
	#dim k as %String = ""
	// Build the parameter string, of the form: a=b&c=d
	set k = ""
	while (1)
	{
		#dim v as %String = encodedArray.GetNext(.k)
		quit:k=""
		do ..AppendQueryParameter(.queryString, k, v)
	}
	quit queryString
]]></Implementation>
</Method>

<Method name="AppendQueryParameter">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&queryString:%String,k:%String,v:%String="",appendIfEmpty:%Boolean=0]]></FormalSpec>
<Implementation><![CDATA[
	if ((v '= "") || appendIfEmpty)
	{
		if ($length(queryString) > 0)
		{
			set queryString = queryString _ "&"
		}
		if (v = "")
		{
			set queryString = queryString _ k
		}
		else
		{
			set queryString = queryString _ k _ "=" _ v
		}
	}
]]></Implementation>
</Method>

<Method name="ArrayToUrlQueryString">
<ClassMethod>1</ClassMethod>
<FormalSpec>a:%ArrayOfDataTypes</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	#dim queryString as %String = ""
	#dim k as %String = ""
	// Build the parameter string, of the form: a=b&c=d
	set k = ""
	while (1)
	{
		#dim v as %String = a.GetNext(.k)
		quit:k=""
		do ..AppendUrlQueryParameter(.queryString, k, v)
	}
	quit queryString
]]></Implementation>
</Method>

<Method name="AppendUrlQueryParameter">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&queryString:%String,k:%String,v:%String="",includeIfEmpty:%Boolean=0]]></FormalSpec>
<Implementation><![CDATA[
	if ((v '= "") || includeIfEmpty)
	{
		if ($length(queryString) '= 0)
		{
			set queryString = queryString_"&"
		}
		set k = ##class(Util.Misc).UrlEncode(k)
		set v = ##class(Util.Misc).UrlEncode(v)
		set queryString = queryString _ k _ "=" _ v
	}
]]></Implementation>
</Method>

<Method name="PercentEncodeArray">
<ClassMethod>1</ClassMethod>
<FormalSpec>a:%ArrayOfDataTypes</FormalSpec>
<ReturnType>%ArrayOfDataTypes</ReturnType>
<Implementation><![CDATA[
	// Build sorted array of encoded key/value pairs:
	#dim encodedArray as %ArrayOfDataTypes = ##class(%ArrayOfDataTypes).%New()
	#dim k as %String = ""
	while (1)
	{
		#dim v = a.GetNext(.k)
		quit:k=""
		do encodedArray.SetAt(##class(Util.Misc).UrlEncode(v), ##class(Util.Misc).UrlEncode(k))
	}
	quit encodedArray
]]></Implementation>
</Method>

<Method name="AppendAuthHeaderParameter">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&queryString:%String,k:%String,v:%String=""]]></FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	if ($length(queryString) > 0)
	{
		// Authorisation header parameters are separated by a comma and a space:
		set queryString = queryString _ ", "
	}
	if (v = "")
	{
		set queryString = queryString _ k
	}
	else
	{
		set queryString = queryString _ k _ "=""" _ v _ """"
	}
	quit queryString
]]></Implementation>
</Method>
</Class>
</Export>
