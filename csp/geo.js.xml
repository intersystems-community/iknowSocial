<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25">
<CSP name="geo.js" application="/csp/iknowsocial/" default="1"><![CDATA[
var METERS_IN_KILOMETER = 1000;
var GRADUSES_IN_PI = 180;

function GeoPoint(latitude, longitude) {
	this.latitude = latitude;
	this.longitude = longitude;
}

function toRadians(degree) {
    return (degree * (Math.PI / GRADUSES_IN_PI));
}

function CalcHaversineDistance(lat1, lat2, lon1, lon2) {
	var lat1 = toRadians(lat1);
	var lon1 = toRadians(lon1);
	var lat2 = toRadians(lat2);
	var lon2 = toRadians(lon2);
    var R = 6372.8; // Earth radius, km
    var dLat = lat2 - lat1;
    var dLon = lon2 - lon1;
    var a = Math.sin(dLat / 2) * Math.sin(dLat /2) + Math.sin(dLon / 2) * Math.sin(dLon /2) * Math.cos(lat1) * Math.cos(lat2);
    var c = 2 * Math.asin(Math.sqrt(a));
	return R * c;
}

GeoPoint.prototype.getDistance = function(anotherGeoPoint) {
	if (anotherGeoPoint instanceof GeoPoint) {
		return CalcHaversineDistance(this.latitude, anotherGeoPoint.latitude, this.longitude, anotherGeoPoint.longitude)
	} else {
		return undefined;
	}
}

GeoPoint.prototype.toTuple = function() {
	return [this.latitude, this.longitude];
}

GeoPoint.getMinimumPairwiseDistance = function(centers) {
	var keys = Object.keys(centers);
	var result = Infinity;
	for (var i = 0; i < keys.length; i++) {
		for (var j = i + 1; j < keys.length; j++) {
			result = Math.min(result, centers[keys[i]].getDistance(centers[keys[j]]));
		}
	}
	return result
}

GeoPoint.clusterize = function(points, centers) {
	// this is very inefficient
	
	var clusters = {}
	for (var key in centers) {
		clusters[key] = [];
	}
	
	for (var i = 0; i < points.length; i++) {
		var minDist = Infinity;
		var closestCenter = undefined;
		for (var key in centers) {
			var distToCenter = points[i].getDistance(centers[key]);
			if (minDist > distToCenter) {
				minDist = distToCenter;
				closestCenter = key;
			}
		}
		clusters[closestCenter].push(points[i]);
	}
	
	return clusters;
}

function GeoPost(rawObject) {
	GeoPoint.call(this, rawObject.latitude, rawObject.longitude)
	for (key in rawObject) {
		if (key != "latitude" && key != "longitude") {
			this[key] = rawObject[key];
		}
	}
}

GeoPost.prototype = new GeoPoint();

GeoPost.getFromPosts = function() {
	var array = []
	//console.log(posts)
	for (var i = 0; i < posts.length; i++) {
		//console.log(posts[i]);
		if (posts[i].latitude != "" && posts[i].longitude != "") {
			array.unshift(new GeoPost(posts[i]));
		}
	}
	return array;
}

// initial value is 1 to avoid zero.
GeoPost.getTotalAbsoluteEC = function(array) {
	var result = 1;
	for (var i = 0; i < array.length; i++) {
		result += Math.abs(parseInt(array[i].EC));
	}
	return result;
}

GeoPost.getECDistanceUnit = function(points, centers) {
	var total = GeoPost.getTotalAbsoluteEC(points);
	var pairwiseDistance = GeoPoint.getMinimumPairwiseDistance(centers) * METERS_IN_KILOMETER;
	return pairwiseDistance / total; 
}

var UkraineCities = {
  	"Lviv" 			: new GeoPoint(49.8397, 24.0297),
  	"Donetsk" 		: new GeoPoint(48.0159, 37.8029),
  	"Kyiv" 			: new GeoPoint(50.4501, 30.5234),
  	"Odesa"		 	: new GeoPoint(46.4846, 30.7326),
  	"Sumy" 			: new GeoPoint(50.9077, 34.7981),
  	"Kharkiv" 		: new GeoPoint(49.9935, 36.2304)
}]]></CSP>
</Export>
