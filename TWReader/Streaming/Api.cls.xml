<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25">
<Class name="TWReader.Streaming.Api">
<Super>TWReader.Rest.Api,Util.Http.IChunkCallback</Super>
<TimeCreated>63915,60460.976583</TimeCreated>

<Parameter name="ApiServer">
<Default>stream.twitter.com</Default>
</Parameter>

<Method name="%OnHttpReceive">
<FormalSpec>Data:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #dim status As %Status = $$$OK
    set oldIO = $IO use 0
    #dim proxyObject As %ZEN.proxyObject
    set status = ##class(%ZEN.Auxiliary.jsonProvider).%ConvertJSONToObject(Data, ,.proxyObject)
    goto:$$$ISERR(status) close
    try {
        //do ##class(%ZEN.Auxiliary.jsonProvider).%ObjectToJSON(proxyObject)
#if 0
        #dim smallerObject As %ZEN.proxyObject = ##class(%ZEN.proxyObject).%New()
        set smallerObject.coordinates = proxyObject.coordinates
        set smallerObject.id = proxyObject.id
        set smallerObject.lang = proxyObject.lang
        set smallerObject.place = proxyObject.place
        set smallerObject.text = proxyObject.text
        set smallerObject.user = ##class(%ZEN.proxyObject).%New()
        set smallerObject.user.id = proxyObject.user.id
        set smallerObject.user.lang = proxyObject.user.lang
        set smallerObject.user.name = proxyObject.user.name
        set smallerObject.user.location = proxyObject.user.location
        set smallerObject.user."time_zone" = proxyObject.user."time_zone"
        set smallerObject.user."utc_offset" = proxyObject.user."utc_offset"
        
        // write indented (in a readable form) to the screen
        do ##class(%ZEN.Auxiliary.jsonProvider).%ObjectToJSON(smallerObject)
#else
        #dim username As %String = proxyObject.user."screen_name"
        #dim text As %String = ##class(Util.Misc).RegexpReplace(##class(TWReader.Data.Tweet).CleanValue(proxyObject.text), "\r?\n", " ")
        #dim lang As %String = proxyObject.lang
        
        write "@",username, ":[", lang, "]", text,!
#endif
        do ##class(TWReader.Data.Context).SaveTweet(proxyObject)
        do ..RebuildIknow(0, 0)
    } 
    catch {
        do BACK^%ETN
    }
close
    use oldIO
    return $$$OK
]]></Implementation>
</Method>

<Method name="Write">
<FormalSpec>data:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
#if 0
    // FIXE - uncomment when inherit from %Stream.TmpCharacter
    do ..%OnHttpReceive(data)
    quit ##super(data)
#endif
]]></Implementation>
</Method>

<Method name="CallApiArgs">
<Description>
Almost the same as CallApiArgs from REST API, but providing streaming callbacks</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>apiServer:%String,api:%String,arrayArgs:%ArrayOfDataTypes,*responseText:%String,callback:Util.Http.IChunkCallback=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #dim url As %String = ""
    
    if $match(api,"^https?:.*/.*") { // Full URL given in api will override everything
        // do ..SplitUrl(api, .url, .api)
        set url = api
    } else {
        if $match(apiServer, "^https?:.*") {
            set url = apiServer
        } else {
            set url = "https://" _ apiServer
        }
        if $match(api, "^/.*") {
            set url = url _ api
        } else {
            set url = url _ "/" _ api
        }
    }
    #dim authorizer As Util.Requests.Authorizer = ##class(Util.Requests.Authorizer).%New()
    #dim authHeader as %String = authorizer.GetAuthHeader("get", url, arrayArgs)

    if '$isobject(callback) {
        set callback = ..%New()
    }
    set responseText = ""

    return ##class(Util.Requests.RequestSender).SendHttpRequest(apiServer, api, arrayArgs, .responseText, $$$HTTPLOGLEVEL, authHeader, callback)
]]></Implementation>
</Method>

<Method name="CleanDataExtents">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
    do ##class(TWReader.Data.User).%DeleteExtent()
    do ##class(TWReader.Data.Tweet).%DeleteExtent()
    do ##class(TWReader.Data.Trend).%DeleteExtent()
    do ##class(TWReader.IKnowDomain).%DropData(1,1)
    //do ##class(TWReader.UIBroker).SaveMorePostsByCoords("0", "100", "46.4846", "30.7326", 1)
    //do ##class(TWReader.UIBroker).FetchMorePosts(0, 100, "Харькова", 1)
]]></Implementation>
</Method>

<Method name="Debug">
<ClassMethod>1</ClassMethod>
<FormalSpec>Key:%String,ResetData:%Boolean=1,RebuildDomain:%Boolean=1,SentimentAnalysis:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
    if ResetData { 
        do ..CleanDataExtents() 
    }
    #dim ne,sw As %String = ""
    #dim woeid As %Numeric
    #dim lowKey As %String = $zcvt(Key, "l")
    #dim ukrainanWords As %String = "Ukraine,Украина,ГПУ,АТО"
    #dim russianWords As %String = "Russia,Россия,Российская+Федерация,ВКС"
    #dim kazakhWords As %String = "Казахстан,Kazakhstan,egovkz,ЦОН,OpenData"

    if lowKey = "moscow" {
        set ne = "56.950164,40.285724" // "55.9576,37.967609"
        set sw = "54.660273,35.199055" // "55.4907,37.31926"
        set woeid = 2122265
        set keys = russianWords_",Москва,Moscow"
    } elseif lowKey = "st.pete" {
        set ne = "60.241791,30.75886"
        set sw = "59.633801,29.424641"
        set woeid = 2123260
        set keys = russianWords_",Питер,Санкт-Петербург,С-Петербург,Saint-Peterburgh,Saint-Peterburg,St.Peterburg"
    } elseif lowKey = "russia" {
        //set ne = "81.856903,-168.997849"
        set ne = "81.856903,190.997849"
        set sw = "41.185902,19.638861"
        set woeid = 23424936
        set keys = russianWords
    } elseif lowKey = "kiev" {
        set ne = "50.316879,30.355551"
        set sw = "50.529751,30.581539"
        set woeid = 924938
        set keys = ukrainanWords_",Kiev,Киев"
    } elseif lowKey = "kharkiv" {
        set ne = "50.067001,36.430191"
        set sw = "49.889118,36.066051"
        set woeid = 922137
        set keys = ukrainanWords_",Харьков,Kharkiv"
    } elseif lowKey = "lviv" {
        set ne = "49.897499,24.1388"
        set sw = "49.781319,23.924561"
        set woeid = 924943
        set keys = ukrainanWords_",Львов,Lviv"
    } elseif lowKey = "ukraine" {
        set ne = "52.375359,40.218079"
        set sw = "44.390411,22.128811"
        set woeid = 23424976
        set keys = ukrainanWords
    } elseif lowKey = "astana" {
        set ne = "51.221821,71.497452"
        set sw = "51.153999,71.378922"
        set woeid = 2264962
        set keys = kazakhWords_",Астана,Astana"
    } elseif lowKey = "kazakhstan" {
        set ne = "55.431808,87.312737"
        set sw = "40.566689,46.491859"
        set woeid = 23424871
        set keys = kazakhWords
    } elseif lowKey = "almaty" {
        set ne = "43.397442,77.01651"
        set sw = "43.179569,76.833511"
        set woeid = 2255777
        set keys = kazakhWords
    }
    // FIXME - ok, Twitter uses geoJSON order (longitude,latitude)
    // FIXME - but Google uses (latitude,longitude), we recorded them from Google or 
    // geoplanet-explorer http://isithackday.com/geoplanet-explorer/index.php?start=City
    // so we need to reverse them back
    #dim x, y As %Numeric
#define SwapNums(%string,%x,%y) set $lb(%x,%y) = $lfs(%string,","), %string = $lts($lb(%y,%x),",")
    $$$SwapNums(ne,x,y)
    $$$SwapNums(sw,x,y)
    write "Using query: ", "track="_keys_"&locations="_sw_","_ne,!
    do ..DebugApiCall("/1.1/statuses/filter.json","track="_keys_"&locations="_sw_","_ne)
    do ..RebuildIknow(RebuildDomain, SentimentAnalysis)
]]></Implementation>
</Method>

<Method name="RebuildIknow">
<ClassMethod>1</ClassMethod>
<FormalSpec>RebuildDomain:%Boolean,SentimentAnalysis:%Boolean</FormalSpec>
<Implementation><![CDATA[
    #dim context As Util.Data.Context = ##class(TWReader.Data.Context).%New(0)
    if RebuildDomain {
        do context.Rebuild(0) // no need to reset domain again
    }
    if SentimentAnalysis {
        do context.CalculateEmotionalColoring()
    }
]]></Implementation>
</Method>
</Class>
</Export>
