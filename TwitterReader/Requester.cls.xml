<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25">
<Class name="TwitterReader.Requester">
<Super>%RegisteredObject</Super>
<TimeCreated>62712,66841.110061</TimeCreated>

<UDLText name="T">
<Content><![CDATA[
/*
History
Ed	Date		By			Comments
#02	2013-06-10	Paul Dayan	History begins. Added capability to send a status update (tweet). Added capability to make
							request with specific application credentials.
*/
]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
/*
See
https://dev.twitter.com/docs/auth/authorizing-request
for guidance on sending authorised requests to the Twitter API.
*/
]]></Content>
</UDLText>

<Parameter name="AuthHeaderName">
<Default>Authorization</Default>
</Parameter>

<Parameter name="AuthPrefix">
<Default>OAuth </Default>
</Parameter>

<UDLText name="T">
<Content><![CDATA[
// application : iKnowCacheDemo

]]></Content>
</UDLText>

<Parameter name="ConsumerKey">
<Default>WpT9B0QNyGo0rMP3UxJfKA</Default>
</Parameter>

<Parameter name="ConsumerSecret">
<Default>W4LEDTYhUYZZHkagJTsjyN67DolAjZ3SuR1TvqU80iI</Default>
</Parameter>

<Parameter name="AuthToken">
<Default>1885599715-fiwI4aLgQzdbgYhjHT7whqPC8xmTpr4mNjlskpg</Default>
</Parameter>

<Parameter name="AuthTokenSecret">
<Default>qpaGPTKL7gsU3a3beEsD3UFHiTW0WCt7p28PASBy6Ww</Default>
</Parameter>

<Parameter name="BaseSSLURL">
<Default>https://api.twitter.com</Default>
</Parameter>

<Parameter name="SslTlsConfig">
<Default>Twitter</Default>
</Parameter>

<Parameter name="ApiServer">
<Default>api.twitter.com</Default>
</Parameter>

<Parameter name="ApiUserTimelineUrl">
<Default>1.1/statuses/user_timeline.json</Default>
</Parameter>

<Parameter name="ApiSearchUrl">
<Default>1.1/search/tweets.json</Default>
</Parameter>

<Parameter name="ApiStatusUpdateUrl">
<Default>1.1/statuses/update.json</Default>
</Parameter>

<Parameter name="SignatureMethod">
<Default>HMAC-SHA1</Default>
</Parameter>

<Parameter name="AuthVersion">
<Default>1.0</Default>
</Parameter>

<Parameter name="NonceTest">
<Default>06270ad7f4ce66daf19955beec39f898</Default>
</Parameter>

<Parameter name="TestNonce">
<Default>0</Default>
</Parameter>

<Parameter name="RequestTest">
<Default>0</Default>
</Parameter>

<Property name="SslTlsCredentials">
<Description>
The name of the Cache SSL/TLS configuration to use.
See:
http://localhost:57772/csp/docbook/DocBook.UI.Page.cls?KEY=GCAS_ssltls#GCAS_ssltls_createedit</Description>
<Type>%String</Type>
</Property>

<Property name="AccessToken">
<Type>%String</Type>
</Property>

<Property name="AccessTokenSecret">
<Type>%String</Type>
</Property>

<Property name="AppConsumerKey">
<Type>%String</Type>
</Property>

<Property name="AppConsumerSecret">
<Type>%String</Type>
</Property>

<Property name="SigningKey">
<Type>%String</Type>
<Calculated>1</Calculated>
<ReadOnly>1</ReadOnly>
</Property>

<Method name="%OnNew">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim status as %Status = $$$OK
	set ..SslTlsCredentials = ..#SslTlsConfig
	set ..AccessToken = ..#AuthToken
	set ..AccessTokenSecret = ..#AuthTokenSecret
	set ..AppConsumerKey = ..#ConsumerKey
	set ..AppConsumerSecret = ..#ConsumerSecret
	quit status
]]></Implementation>
</Method>

<Method name="SigningKeyGet">
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	quit ##class(Utils).UrlEncode(..AppConsumerSecret) _ "&" _ ##class(Utils).UrlEncode(..AccessTokenSecret)
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
/*
I think we need to use Search rather than User Timeline. That way we can find replies to a primary tweet, which is
what we need to do in order to derive the sentiment in response to that post.
*/
]]></Content>
</UDLText>

<Method name="UserTimeline">
<FormalSpec>userId:%String="",screenName:%String="",sinceId:%Integer="",count:%Integer=20,maxId:%Integer="",trimUser:%Boolean=0,excludeReplies:%Boolean=0,contributorDetails:%Boolean=0,includeRts:%Boolean=0</FormalSpec>
<ReturnType>%ListOfObjects</ReturnType>
<Implementation><![CDATA[
	#dim a as %ArrayOfDataTypes = ##class(%ArrayOfDataTypes).%New()
	#dim location as %String = ..#ApiUserTimelineUrl
	#dim url = "https://" _ ..#ApiServer _ "/" _ location
	/*
	The exclude_replies parameter is not very useful, because count includes replies even if exclude_replies is true.
	So a query could return no tweets, and you wouldn't be able to tell if that was because there are no more tweets
	or because all the tweets in that batch of <count> were replies. So you've got no way of knowing when to stop
	querying if, say, you're trying to fetch 100 non-reply tweets. Also, you wouldn't know the id of the last tweet
	if all the tweets were replies, so you wouldn't know what to set the max_id to for the next request.
	The only answer is to fetch the replies and filter them out yourself.
	*/
	do ..AddParameter(a, "user_id", userId)
	do ..AddParameter(a, "screen_name", screenName)
	do ..AddParameter(a, "since_id", sinceId)
	do ..AddParameter(a, "count", count, , 20)
	do ..AddParameter(a, "max_id", maxId)
	do ..AddParameter(a, "trim_user", ##class(Utils).GetBool(trimUser), , ##class(Utils).#False)
	do ..AddParameter(a, "exclude_replies", ##class(Utils).GetBool(excludeReplies), , ##class(Utils).#False)
	do ..AddParameter(a, "contributor_details", ##class(Utils).GetBool(contributorDetails), , ##class(Utils).#False)
	do ..AddParameter(a, "include_rts", ##class(Utils).GetBool(includeRts), , ##class(Utils).#True)
	#dim query as %String = ..ArrayToUrlQueryString(a)
	#dim queryUrl = ..AppendQueryParametersToUrl(url, query)
	#dim authQuery as %String
	#dim authHeader as %String = ..GetAuthHeaderOLD("get", url, .authQuery, a)
	//write authHeader, !
	//write url, !
	#dim responseData as %String
	
	#dim status as %Status = ..SendHttpRequest(..#ApiServer, location, .responseData, a, 1, authHeader)
	write "Response data:"_responseData, !
	#dim tweets as %ListOfObjects = ..ResponseJsonToTweets(responseData, userId, screenName)
	quit tweets
]]></Implementation>
</Method>

<Method name="Search">
<FormalSpec>queryString:%String,resultType:%String="recent",sinceId:%Integer="",until:%Date,count:%Integer=15,maxId:%Integer=""</FormalSpec>
<ReturnType>%ListOfObjects</ReturnType>
<Implementation><![CDATA[
	// See
	// https://dev.twitter.com/docs/using-search
	// for information on constructing the query string
	/* Query keywords in query string:
Example						Finds tweets...
twitter search				containing both "twitter" and "search". This is the default operator
"happy hour"				containing the exact phrase "happy hour"
love OR hate				containing either "love" or "hate" (or both)
beer -root					containing "beer" but not "root"
#haiku						containing the hashtag "haiku"
from:twitterapi				sent from the user @twitterapi
to:twitterapi				sent to the user @twitterapi
place:opentable:2			about the place with OpenTable ID 2
place:247f43d441defc03		about the place with Twitter ID 247f43d441defc03
@twitterapi					mentioning @twitterapi
superhero since:2011-05-09	containing "superhero" and sent since date "2011-05-09" (year-month-day).
twitterapi until:2011-05-09	containing "twitterapi" and sent before the date "2011-05-09".
movie -scary :)				containing "movie", but not "scary", and with a positive attitude.
flight :(					containing "flight" and with a negative attitude.
traffic ?					containing "traffic" and asking a question.
hilarious filter:links		containing "hilarious" and with a URL.
news source:tweet_button	containing "news" and entered via the Tweet Button

	*/
	#dim a as %ArrayOfDataTypes = ##class(%ArrayOfDataTypes).%New()
	#dim location as %String = ..#ApiSearchUrl
	#dim url = "https://" _ ..#ApiServer _ "/" _ location
	do ..AddParameter(a, "q", queryString)
	do ..AddParameter(a, "result_type", resultType)
	do ..AddParameter(a, "since_id", sinceId)
	do ..AddParameter(a, "until", ..DateToString(until))	// date in format YYYY-MM-DD
	do ..AddParameter(a, "max_id", maxId)
	do ..AddParameter(a, "count", count, , 15)	// if count omitted, Twitter defaults to 15
	#dim query as %String = ..ArrayToUrlQueryString(a)
	#dim queryUrl = ..AppendQueryParametersToUrl(url, query)
	
	#dim authQuery as %String
	#dim authHeader as %String = ..GetAuthHeader("get", url, .authQuery, a)
	
	//s authHeader = "Authorization: "_authHeader
	write "authHeader ="_authHeader, !

	#dim responseData as %String
	#dim status as %Status = ..SendHttpRequest(..#ApiServer, location, .responseData, a, 1, authHeader)
	
	#dim tweets as %ListOfObjects = ..ResponseJsonToTweets(responseData)
	quit tweets
]]></Implementation>
</Method>

<Method name="SendTweet">
<Description><![CDATA[
Send a status update (tweet) from the application's own account.
This is the only way to send a tweet without user intervention (to login on Twitter) without getting xAuth
approval from Twitter (see: https://dev.twitter.com/docs/oauth/xauth).
<parameter>tweetText</parameter> The text of the status update.
<parameter>directReplyToUserId</parameter> If not null (the default), the Twitter username of the user to send a
direct message to. Twitter only permits this if the user is a follower of the sender.
<parameter>inReplyToStatusId</parameter> If not null, the tweet ID of the tweet being replied to.
<parameter>latitude</parameter> If not null, the latitude of the location the tweet is from.
<parameter>longitude</parameter> If not null, the longitude of the location the tweet is from.]]></Description>
<FormalSpec>tweetText:%String,directReplyToUserId:%String="",inReplyToStatusId:%String="",latitude:%Double="",longitude:%Double=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// See:
	// https://dev.twitter.com/docs/api/1.1/post/statuses/update
	#dim a as %ArrayOfDataTypes = ##class(%ArrayOfDataTypes).%New()
	#dim b as %ArrayOfDataTypes = ##class(%ArrayOfDataTypes).%New()
	#dim location as %String = ..#ApiStatusUpdateUrl
	#dim url = "https://" _ ..#ApiServer _ "/" _ location
	if (directReplyToUserId '= "")
	{
		// Send direct message to specified user. Prefix tweet with "D <user name> ":
		set tweetText = "D " _ directReplyToUserId _ " " _ tweetText
	}
	do ..AddParameter(a, "status", tweetText)
	do ..AddParameter(a, "in_reply_to_status_id", inReplyToStatusId)
	do ..AddParameter(a, "lat", latitude)
	do ..AddParameter(a, "long", longitude)
	#dim query as %String = ..ArrayToUrlQueryString(a)
	#dim queryUrl = ..AppendQueryParametersToUrl(url, query)
	#dim authQuery as %String
	#dim authHeader as %String = ..GetAuthHeader("post", url, .authQuery, a)
	//write authHeader, !
	write url, !
	#dim responseData as %String
	#dim status as %Status = ..SendHttpRequest(..#ApiServer, location, .responseData, a, 1, authHeader, b)
	if (responseData '= "")
	{
		write "Response data:", !
		write responseData, !
	}
	quit status
]]></Implementation>
</Method>

<Method name="ResponseJsonToTweets">
<FormalSpec>responseData:%String,userId:%String="",screenName:%String=""</FormalSpec>
<ReturnType>%ListOfObjects</ReturnType>
<Implementation><![CDATA[
	#dim tweets as %ListOfObjects = ##class(%ListOfObjects).%New()
	// %ConvertJSONToObject can't handle JSON that is just an array, so wrap an array as an object with an array property:
	if (($length(responseData) > 0) && ($extract(responseData, 1) = "["))
	{
		set responseData = "{ ""tweets"":" _ responseData _ " }"
	}
	#dim responseTweets as %ZEN.proxyObject
	#dim status as %Status = ##class(%ZEN.Auxiliary.jsonProvider).%ConvertJSONToObject(responseData, , .responseTweets)
	//write "JSON status: ",$system.Status.DisplayError(status),!
	//write $classname(responseTweets), !
	#dim props as %ListOfObjects
	do responseTweets.%CopyToArray(.props)
	#dim dataStatus = $data(props)
	if (dataStatus = 10)
	{
		//write "props(tweets) is defined: ",$data(props("tweets")),", props(tweets) is null: ",props("tweets")="",!
		#dim x as %ListOfObjects
		set dataStatus = $data(props("tweets"), x)	// get the tweets collection
		set:dataStatus=0 dataStatus = $data(props("statuses"), x)	// get the tweets collection
		// Properties of a tweet:
		// annotations
		// contributors - (beta feature)
		// coordinates
		// created_at - date/time
		// current_user_retweet
		// entities - entities parsed out of the text
		// favorited
		// id
		// id_str
		// in_reply_to_screen_name
		// in_reply_to_status_id - non-null if the tweet is a reply
		// in_reply_to_status_id_str - non-null if the tweet is a reply
		// in_reply_to_user_id
		// in_reply_to_user_id_str 
		// place
		// possibly_sensitive
		// scopes
		// retweet_count
		// retweeted
		// source - how the tweet was posted, e.g. if posted using the Twitter website = "web"
		// text - the tweet text, UTF-8
		// truncated
		// user
		// withheld_copyright
		// withheld_in_countries
		// withheld_scope
		//
		// Probably relevant are:
		// created_at - date/time
		// id - to keep track of which tweets have been fetched (store highest id)
		// in_reply_to_status_id_str - indicates whether the tweet is a reply
		// place - geographical origin, with properties e.g. "country_code"
		// source - may be useful
		// text - obviously - does this need any conversion to Unicode?
		// user - perhaps some aspects later, such as age if available
		//
		// We can't simply index into the list of tweets (e.g. x(1)). Instead we have to
		// iterate over the objects using %ListOfObjects.GetNext(). Or we can use GetAt(i), stopping
		// at Count() elements, or when GetAt(i) returns null (it doesn't throw an exception if i is out of
		// range.
		#dim tweetCount as %Integer = x.Count()
		for i=1:1:tweetCount
		{
			//#dim xt as %ZEN.proxyObject = x.GetNext(.key)
			//quit:key=""
			#dim xt as %ZEN.proxyObject = x.GetAt(i)
			//write "Key: ", key, !
			// Note: we can't pass in the object resulting from xt.%CopyToArray, as this throws an UNDEFINED
			// exception. The result of %CopyToArray appears to be a multi-dimensional array with subscripts
			// but no direct value.
			#dim tweet as Tweet = ##class(Tweet).%New(userId, screenName, xt)
			do tweets.Insert(tweet)
		}
	}
	quit tweets
]]></Implementation>
</Method>

<Method name="JsonToTweets">
<ClassMethod>1</ClassMethod>
<FormalSpec>json:%String</FormalSpec>
<Implementation><![CDATA[	do ##class(%ZEN.Auxiliary.jsonProvider).%ConvertJSONToObject()
]]></Implementation>
</Method>

<Method name="SendHttpRequest">
<FormalSpec><![CDATA[server:%String,location:%String,&responseText:%String(MAXLEN=1000000),parameters:%ArrayOfDataTypes="",useSsl:%Boolean=0,authorization:%String="",postArray:%ArrayOfDataTypes=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim req as %Net.HttpRequest = ##class(%Net.HttpRequest).%New()
	set req.Server = server
	set req.Location = location
	if (authorization '= "")
	{
		set req.Authorization = authorization
	}
	if (useSsl)
	{
		set req.Https = 1
		set req.SSLConfiguration = ..SslTlsCredentials
	}
	
	#dim k as %String = ""
	#dim v as %String = ""
	if (parameters '= "")
	{
		set k = ""
		while (1)
		{
			set v = parameters.GetNext(.k)
			quit:k=""
			//write "params = "_k_" ! "_v ,!
			do req.InsertParam(k, v)
		}
	}
	#dim test as %Integer = ..#RequestTest	// 0 => request made, no request printout, 1 => request printout, no request, 2 => request printout and request made
	if (test '= 0)
	{
		write "Request:",!
		write "Server: ", req.Server, ", Location: ", req.Location, !
	}
	#dim status as %Status = $$$OK
	#dim asPost as %Boolean = 0
	if (postArray '= "")
	{
		set asPost = 1
		set k = ""
		while (1)
		{
			set v = postArray.GetNext(.k)
			quit:k=""
			do req.InsertFormData(k, v)
		}
	}
	if (asPost)
	{
		set status = req.Post(location, test)
	}
	else
	{
		set status = req.Get(location, test)
		write "request status"_status, !
	}
	if ($$$ISOK(status))
	{
		#dim response as %String = ""
		if (test '= 1)
		{
			#dim res as %Net.HttpResponse = req.HttpResponse
			if ($data(res))
			{
				write "Response: ", res.StatusCode, ", ", res.StatusLine, ", ", res.ReasonPhrase, !
			}
			if ($$$ISOK(status))
			{
				#dim responseLength as %Integer = 1000000
				set response = res.Data.Read(.responseLength)
				write "Response type: ", $classname(res.Data), !
				write "Response length: ", $length(response), ", ", responseLength, !
			}
		}
		set responseText = response
	}
	else
	{
		set responseText = ""
	}
	quit status
]]></Implementation>
</Method>

<Method name="GetNonce">
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	// Increment the persisted nonce counter and return the incremented value.
	// If the persisted global does not exist, $increment creates it and sets it to 1.
	quit:..#TestNonce ..#NonceTest
	//quit $increment(^TwitterReader.NextNonce)
	quit ..GetGUID()
]]></Implementation>
</Method>

<Method name="GetStatusAuthQuery">
<FormalSpec>action:%String,url:%String,status:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	#dim includeEntities as %Boolean = 1
]]></Implementation>
</Method>

<Method name="GetAuthHeader">
<FormalSpec>action:%String,url:%String,*query:%String,parameters:%ArrayOfDataTypes=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	#dim nonce as %String = $replace(..GetNonce(),"-","")	// "06270ad7f4ce66daf19955beec39f898"
	#dim unixTime as %Integer = ##class(Utils).GetUnixTime()	// 1347573260
	#dim h as %ArrayOfDataTypes = ##class(%ArrayOfDataTypes).%New()
	do h.SetAt("OkmQ10HOuizoKvZc42Y9t5zLf", "oauth_consumer_key")
	do h.SetAt(nonce, "oauth_nonce")
	do h.SetAt("HMAC-SHA1", "oauth_signature_method")
	do h.SetAt(unixTime, "oauth_timestamp")
	do h.SetAt(..AccessToken, "oauth_token")
	do h.SetAt(..#AuthVersion, "oauth_version")
	#dim a as %ArrayOfDataTypes = h.%ConstructClone(1)
	do ..AppendArray(a, parameters)
	set query = ..RequestArrayToQueryString(action, url, a)
	write "Query: ", query, !
	#dim signatureBase as %String = ..CreateSignature(query, ..SigningKey)
	#dim signature as %String = $system.Encryption.Base64Encode(signatureBase)
	do h.SetAt(signature, "oauth_signature")
	quit ..BuildAuthHeader(h)
]]></Implementation>
</Method>

<Method name="GetAuthHeaderOLD">
<FormalSpec>action:%String,url:%String,*query:%String,parameters:%ArrayOfDataTypes=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	#dim nonce as %String = $replace(..GetNonce(),"-","")	// "06270ad7f4ce66daf19955beec39f898"
	write "nonce: ", $replace(nonce,"-",""), !
	#dim unixTime as %Integer = ##class(Utils).GetUnixTime()	// 1347573260
	#dim h as %ArrayOfDataTypes = ##class(%ArrayOfDataTypes).%New()
	do h.SetAt(..AppConsumerKey, "oauth_consumer_key")
	do h.SetAt(nonce, "oauth_nonce")
	do h.SetAt("HMAC-SHA1", "oauth_signature_method")
	do h.SetAt(unixTime, "oauth_timestamp")
	do h.SetAt(..AccessToken, "oauth_token")
	do h.SetAt(..#AuthVersion, "oauth_version")
	#dim a as %ArrayOfDataTypes = h.%ConstructClone(1)
	do ..AppendArray(a, parameters)
	set query = ..RequestArrayToQueryString(action, url, a)
	write "Query: ", query, !
	#dim signatureBase as %String = ..CreateSignature(query, ..SigningKey)
	#dim signature as %String = $system.Encryption.Base64Encode(signatureBase)
	do h.SetAt(signature, "oauth_signature")
	quit ..BuildAuthHeader(h)
]]></Implementation>
</Method>

<Method name="BuildAuthHeader">
<ClassMethod>1</ClassMethod>
<FormalSpec>parameters:%ArrayOfDataTypes</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	#dim encodedArray as %ArrayOfDataTypes = ..PercentEncodeArray(parameters)
	// Build the header string, of the form: OAuth a="b",c="d"
	#dim dst as %String = ""
	#dim k as %String = ""
	set k = ""
	while (1)
	{
		#dim v as %String = encodedArray.GetNext(.k)
		quit:k=""
		do ..AppendAuthHeaderParameter(.dst, k, v)
	}
	// Note: we prefix with the header _after_ building the parameter list because AppendAuthHeaderParameter
	// relies on the string being initially empty to decide whether to add a ", " before adding a parameter.
	set dst = ..#AuthPrefix _ dst
	write "dst: ", dst, !
	quit dst
]]></Implementation>
</Method>

<Method name="RequestToQueryString">
<ClassMethod>1</ClassMethod>
<FormalSpec>action:%String,url:%String,parameters...</FormalSpec>
<Implementation><![CDATA[
	#dim a as %ArrayOfDataTypes = ##class(%ArrayOfDataTypes).%New()
	#dim i as %Integer
	#dim k as %String
	for i=1:2
	{
		quit:'$data(parameters(i), k)
		#dim v as %String = parameters(i + 1)
		do a.SetAt(v, k)
	}
	quit ..RequestArrayToQueryString(action, url, a)
]]></Implementation>
</Method>

<Method name="RequestArrayToQueryString">
<ClassMethod>1</ClassMethod>
<FormalSpec>action:%String,url:%String,parameters:%ArrayOfDataTypes</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	#dim queryString as %String = ""
	set action = $zconvert(action, "U")
	do ..AppendQueryParameter(.queryString, action, "", 1)
	do ..AppendQueryParameter(.queryString, ##class(Utils).UrlEncode(url), "", 1)
	#dim q as %String = ..ArrayToQueryString(parameters)
	set q = ##class(Utils).UrlEncode(q)
	if (q '= "")
	{
		set queryString = queryString _ "&" _ q
	}
	quit queryString
]]></Implementation>
</Method>

<Method name="PercentEncodeArray">
<ClassMethod>1</ClassMethod>
<FormalSpec>a:%ArrayOfDataTypes</FormalSpec>
<ReturnType>%ArrayOfDataTypes</ReturnType>
<Implementation><![CDATA[
	// Build sorted array of encoded key/value pairs:
	#dim encodedArray as %ArrayOfDataTypes = ##class(%ArrayOfDataTypes).%New()
	#dim k as %String = ""
	while (1)
	{
		#dim v = a.GetNext(.k)
		quit:k=""
		do encodedArray.SetAt(##class(Utils).UrlEncode(v), ##class(Utils).UrlEncode(k))
	}
	quit encodedArray
]]></Implementation>
</Method>

<Method name="ArrayToQueryString">
<ClassMethod>1</ClassMethod>
<FormalSpec>a:%ArrayOfDataTypes</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	#dim queryString as %String = ""
	// Build sorted array of encoded key/value pairs:
	#dim encodedArray as %ArrayOfDataTypes = ..PercentEncodeArray(a)
	#dim k as %String = ""
	// Build the parameter string, of the form: a=b&c=d
	set k = ""
	while (1)
	{
		#dim v as %String = encodedArray.GetNext(.k)
		quit:k=""
		do ..AppendQueryParameter(.queryString, k, v)
	}
	quit queryString
]]></Implementation>
</Method>

<Method name="ArrayToUrlQueryString">
<ClassMethod>1</ClassMethod>
<FormalSpec>a:%ArrayOfDataTypes</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	#dim queryString as %String = ""
	#dim k as %String = ""
	// Build the parameter string, of the form: a=b&c=d
	set k = ""
	while (1)
	{
		#dim v as %String = a.GetNext(.k)
		quit:k=""
		do ..AppendUrlQueryParameter(.queryString, k, v)
	}
	quit queryString
]]></Implementation>
</Method>

<Method name="AppendUrlQueryParameter">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&queryString:%String,k:%String,v:%String="",includeIfEmpty:%Boolean=0]]></FormalSpec>
<Implementation><![CDATA[
	if ((v '= "") || includeIfEmpty)
	{
		if ($length(queryString) '= 0)
		{
			set queryString = queryString_"&"
		}
		set k = ##class(Utils).UrlEncode(k)
		set v = ##class(Utils).UrlEncode(v)
		set queryString = queryString _ k _ "=" _ v
	}
]]></Implementation>
</Method>

<Method name="AppendQueryParametersToUrl">
<ClassMethod>1</ClassMethod>
<FormalSpec>url:%String,query:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	if ($length(query) > 0)
	{
		set url = url _ "?" _ query
	}
	quit url
]]></Implementation>
</Method>

<Method name="AppendQueryParameter">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&queryString:%String,k:%String,v:%String="",appendIfEmpty:%Boolean=0]]></FormalSpec>
<Implementation><![CDATA[
	if ((v '= "") || appendIfEmpty)
	{
		if ($length(queryString) > 0)
		{
			set queryString = queryString _ "&"
		}
		if (v = "")
		{
			set queryString = queryString _ k
		}
		else
		{
			set queryString = queryString _ k _ "=" _ v
		}
	}
]]></Implementation>
</Method>

<Method name="AppendAuthHeaderParameter">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&queryString:%String,k:%String,v:%String=""]]></FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	if ($length(queryString) > 0)
	{
		// Authorisation header parameters are separated by a comma and a space:
		set queryString = queryString _ ", "
	}
	if (v = "")
	{
		set queryString = queryString _ k
	}
	else
	{
		set queryString = queryString _ k _ "=""" _ v _ """"
	}
	quit queryString
]]></Implementation>
</Method>

<Method name="CreateSignature">
<ClassMethod>1</ClassMethod>
<FormalSpec>text:%String,key:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	quit $system.Encryption.HMACSHA1(text, key)
]]></Implementation>
</Method>

<Method name="AppendArray">
<ClassMethod>1</ClassMethod>
<FormalSpec>a:%ArrayOfDataTypes,b:%ArrayOfDataTypes</FormalSpec>
<Implementation><![CDATA[
	if (b '= "")
	{
		#dim k as %String = ""
		set k = ""
		while (1)
		{
			#dim v as %String = b.GetNext(.k)
			quit:k=""
			do a.SetAt(v, k)
		}
	}
]]></Implementation>
</Method>

<Method name="AddParameter">
<ClassMethod>1</ClassMethod>
<FormalSpec>a:%ArrayOfDataTypes,k:%String,v:%String,addIfDefault:%Boolean=0,defaultV:%String=""</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	#dim add as %Boolean = addIfDefault || (v '= defaultV)
	if (add)
	{
		do a.SetAt(v, k)
	}
	quit add
]]></Implementation>
</Method>

<Method name="GetGUID">
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	quit $system.Util.CreateGUID()
]]></Implementation>
</Method>

<Method name="DateToString">
<ClassMethod>1</ClassMethod>
<FormalSpec>d:%Date</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	#dim dateText as %String = ""
	set:d'="" dateText = $zdate(d, 3)	// date in the format: YYYY-MM-DD
	quit dateText
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// Tests

]]></Content>
</UDLText>

<Method name="TestPercentEncode">
<ClassMethod>1</ClassMethod>
<FormalSpec>text:%String</FormalSpec>
<Implementation><![CDATA[	write ##class(Utils).UrlEncode(text), !
]]></Implementation>
</Method>

<Method name="TestSort">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	// This demonstrates that an array is automatically kept sorted by ascending key.
	#dim a as %ArrayOfDataTypes = ##class(%ArrayOfDataTypes).%New()
	do a.SetAt("1", "z")
	do a.SetAt("2", "a")
	do a.SetAt("3", "m")
	#dim k as %String = ""
	while (1)
	{
		set k = a.Next(k)
		quit:k=""
		write k, !
	}
]]></Implementation>
</Method>

<Method name="TestRequestToQueryString">
<ClassMethod>1</ClassMethod>
<FormalSpec>action:%String,url:%String</FormalSpec>
<Implementation><![CDATA[
	write action _ ", " _ url, !
	write ..RequestToQueryString(action, url, "bravo", "456", "alpha", "123"), !
]]></Implementation>
</Method>

<Method name="TestAppendArray">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	#dim a as %ArrayOfDataTypes = ##class(%ArrayOfDataTypes).%New()
	#dim b as %ArrayOfDataTypes = ##class(%ArrayOfDataTypes).%New()
	do a.SetAt("First", "f")
	do a.SetAt("Second", "s")
	do b.SetAt("Third", "t")
	do b.SetAt("Fourth", "o")
	do ..AppendArray(a, b)
	zw a
]]></Implementation>
</Method>

<Method name="TestGetAuthQuery">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	#dim a as %ArrayOfDataTypes = ##class(%ArrayOfDataTypes).%New()
	do a.SetAt(##class(Utils).GetBool(1), "include_entities")
	do a.SetAt("Hello Ladies + Gentlemen, a signed OAuth request!", "status")
	#dim requester as Requester = ##class(Requester).%New()
	#dim query as %String
	#dim authHeader as %String = requester.GetAuthHeader("get", ..#ApiUserTimelineUrl, .query, a)
	w authHeader, !
	w query, !
]]></Implementation>
</Method>

<Method name="TestUserTimeline">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	/*
Signature base string
 GET&https%3A%2F%2Fapi.twitter.com%2F1.1%2Fstatuses%2Fuser_timeline.json&count%3D2%26oauth_consumer_key%3D6fWTdO0xv63IQ2xWgdH4w%26oauth_nonce%3D06270ad7f4ce66daf19955beec39f898%26oauth_signature_method%3DHMAC-SHA1%26oauth_timestamp%3D1347573260%26oauth_token%3D817942764-ougmHKdDF0PVWnIkuZ4wp1qncTU3TLMmzq6dKd6m%26oauth_version%3D1.0%26screen_name%3Dtwitterapi 
Authorization header
 Authorization: OAuth oauth_consumer_key="6fWTdO0xv63IQ2xWgdH4w", oauth_nonce="06270ad7f4ce66daf19955beec39f898", oauth_signature="Rxn9AL5LNgIGS3olkF3sC5JF3jw%3D", oauth_signature_method="HMAC-SHA1", oauth_timestamp="1347573260", oauth_token="817942764-ougmHKdDF0PVWnIkuZ4wp1qncTU3TLMmzq6dKd6m", oauth_version="1.0" 
cURL command
 curl --get 'https://api.twitter.com/1.1/statuses/user_timeline.json' --data 'count=2&screen_name=twitterapi' --header 'Authorization: OAuth oauth_consumer_key="6fWTdO0xv63IQ2xWgdH4w", oauth_nonce="06270ad7f4ce66daf19955beec39f898", oauth_signature="Rxn9AL5LNgIGS3olkF3sC5JF3jw%3D", oauth_signature_method="HMAC-SHA1", oauth_timestamp="1347573260", oauth_token="817942764-ougmHKdDF0PVWnIkuZ4wp1qncTU3TLMmzq6dKd6m", oauth_version="1.0"' --verbose 
	*/
	#dim requester as Requester = ##class(Requester).%New()
	#dim excludeReplies as %Boolean = 0
	#dim notReplyTweets as %ListOfObjects = ##class(%ListOfObjects).%New()
	#dim replyTweets as %ListOfObjects = ##class(%ListOfObjects).%New()
	#dim targetCount = 5
	#dim maxId as %Integer = ""
	// Get targetCount non-reply tweets. We have to do it iteratively, as exclude_replies is useless (see above).
	while (notReplyTweets.Count() < targetCount)
	{
		#dim tweets as %ListOfObjects = requester.UserTimeline(, "CocaCola",,100,maxId,,excludeReplies)
		#dim count = tweets.Count()
		quit:count=0
		for i=1:1:count
		{
			#dim tweet as Tweet = tweets.GetAt(i)
			set maxId = tweet.StatusId
			// We don't want replies:
			if ('tweet.IsReply)
			{
				do notReplyTweets.Insert(tweet)
			}
			else
			{
				do replyTweets.Insert(tweet)
			}
			quit:notReplyTweets.Count()=targetCount
		}
		set maxId = maxId - 1	// next iteration start with tweet before the last one we've already seen (tweets are returned in reverse time order)
		write "Collected so far: ", notReplyTweets.Count(), !
	}
	#dim repliesCount as %Integer = replyTweets.Count()
	#dim resultCount as %Integer = notReplyTweets.Count()
	for i=1:1:resultCount
	{
		set tweet = notReplyTweets.GetAt(i)
		write tweet.StatusId, " ", $zdatetime(tweet.CreatedAtDateTime)
		if (tweet.IsReply)
		{
			write " (reply)"
		}
		write ": '", tweet.Text, "'", !
		// Find replies to this tweet:
		// TODO: this is rubbish. The replies to a tweet do not appear in the timeline of the original tweeting
		// user.
		// We would have to do a search (using the Search) API, looking for to:<screen name>, and then match
		// the in_reply_to_status_id with the id of the original tweet.
		#dim repliesToThisTweet as %ListOfObjects = ##class(%ListOfObjects).%New()
		for j=1:1:repliesCount
		{
			#dim replyTweet as Tweet = replyTweets.GetAt(j)
			if (replyTweet.InReplyToStatusId = tweet.StatusId)
			{
				do repliesToThisTweet.Insert(replyTweet)
			}
		}
		#dim repliesToThisTweetCount as %Integer = repliesToThisTweet.Count()
		if (repliesToThisTweetCount > 0)
		{
			write "Replies: "
			for j=1:1:repliesToThisTweetCount
			{
				if (j > 1)
				{
					write ", "
				}
				set replyTweet = repliesToThisTweet.GetAt(j)
				write "'", replyTweet.Text, "'"
			}
			write !
		}
		//zw tweet
	}
	write resultCount, " tweets", !
]]></Implementation>
</Method>

<Method name="TestFetchAndSaveUserTimeline">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	/*
Signature base string
 GET&https%3A%2F%2Fapi.twitter.com%2F1.1%2Fstatuses%2Fuser_timeline.json&count%3D2%26oauth_consumer_key%3D6fWTdO0xv63IQ2xWgdH4w%26oauth_nonce%3D06270ad7f4ce66daf19955beec39f898%26oauth_signature_method%3DHMAC-SHA1%26oauth_timestamp%3D1347573260%26oauth_token%3D817942764-ougmHKdDF0PVWnIkuZ4wp1qncTU3TLMmzq6dKd6m%26oauth_version%3D1.0%26screen_name%3Dtwitterapi 
Authorization header
 Authorization: OAuth oauth_consumer_key="6fWTdO0xv63IQ2xWgdH4w", oauth_nonce="06270ad7f4ce66daf19955beec39f898", oauth_signature="Rxn9AL5LNgIGS3olkF3sC5JF3jw%3D", oauth_signature_method="HMAC-SHA1", oauth_timestamp="1347573260", oauth_token="817942764-ougmHKdDF0PVWnIkuZ4wp1qncTU3TLMmzq6dKd6m", oauth_version="1.0" 
cURL command
 curl --get 'https://api.twitter.com/1.1/statuses/user_timeline.json' --data 'count=2&screen_name=twitterapi' --header 'Authorization: OAuth oauth_consumer_key="6fWTdO0xv63IQ2xWgdH4w", oauth_nonce="06270ad7f4ce66daf19955beec39f898", oauth_signature="Rxn9AL5LNgIGS3olkF3sC5JF3jw%3D", oauth_signature_method="HMAC-SHA1", oauth_timestamp="1347573260", oauth_token="817942764-ougmHKdDF0PVWnIkuZ4wp1qncTU3TLMmzq6dKd6m", oauth_version="1.0"' --verbose 
	*/
	#dim folderPath as %String = "C:\\Not backed up\\iKnow test data\\Tweets"
	#dim csvPath as %String = "C:\\Temp\\tweets.csv"
	#dim requester as Requester = ##class(Requester).%New()
	#dim excludeReplies as %Boolean = 0
	#dim countToRead as %Integer = 1000
	#dim countRead as %Integer = 0
	#dim maxId as %Integer = ""
	#dim countRemaining as %Integer = countToRead
	#dim fileNumber as %Integer = 1
	#dim status as %Status = $$$OK
	#dim tweetsFile as %IO.FileStream = ##class(%IO.FileStream).%New()
	do tweetsFile.Open(csvPath, ##class(%IO.FileStream).#WRITENEWOVER,,,.status)
	do tweetsFile.WriteLine("StatusId,CreatedAt,UserId,ScreenName,InReplyToStatusId,InReplyToUserId,InReplyToScreenName,RetweetCount,Retweeted,Source,Truncated,CreatedAtDateTime,IsReply")
	while (countRemaining > 0)
	{
		#dim tweets as %ListOfObjects = requester.UserTimeline(, "CocaCola",,countRemaining,maxId,,excludeReplies)
		#dim count = tweets.Count()
		write "Fetched ", count, " tweets", !
		quit:count=0
		for i=1:1:count
		{
			#dim tweet as Tweet = tweets.GetAt(i)
			#dim path as %String = folderPath _ "\\Tweet" _ fileNumber _ ".txt"
			#dim fs as %IO.FileStream = ##class(%IO.FileStream).%New()
			#dim b as %Boolean = fs.Open(path, ##class(%IO.FileStream).#WRITENEWOVER,,,.status)
			write:$$$ISERR(status) $system.Status.DisplayError(status), !
			if ($$$ISOK(status))
			{
				do fs.WriteLine(tweet.Text, .status)
				write:$$$ISERR(status) $system.Status.DisplayError(status), !
				do fs.Close(.status)
				write:$$$ISERR(status) $system.Status.DisplayError(status), !
			}
			set fileNumber = fileNumber + 1
			if ((maxId = "") || (tweet.StatusId < maxId))
			{
				set maxId = tweet.StatusId - 1
			}
		}
		set countRead = countRead + count
		set countRemaining = countRemaining - count
	}
	write countRead, " tweets read", !
]]></Implementation>
</Method>

<Method name="TestSearch">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	#dim requester as Requester = ##class(Requester).%New()
	#dim queryText as %String = "Ukraine"
	#dim resultType = "popular"
	#dim maxId as %Integer = ""
	#dim sinceId as %Integer = ""
	#dim until as %Date = ""
	#dim count as %Integer = ""
	#dim tweets as %ListOfObjects = requester.Search(queryText, resultType, sinceId, until, count, maxId)
	#dim tweetCount as %Integer = tweets.Count()
	write count, " tweets", !
	for i=1:1:tweetCount
	{
		#dim tweet as Tweet = tweets.GetAt(i)
		write "Reply to status: ", tweet.InReplyToStatusId, ", '", tweet.Text, "'", !
		write tweet.CreatedAtDateTime,!
		write tweet.UserId,!
		d $SYSTEM.OBJ.Dump(tweet) r xxx
	}
]]></Implementation>
</Method>

<Method name="TestStatusUpdate">
<ClassMethod>1</ClassMethod>
<FormalSpec>tweetText:%String</FormalSpec>
<Implementation><![CDATA[
	#dim requester as Requester = ##class(Requester).%New()
	#dim status as %Status = requester.SendTweet(tweetText)
	if ($$$ISOK(status))
	{
		write "Success", !
	}
	else
	{
		write "Error: " _ $system.Status.GetErrorText(status), !
	}
]]></Implementation>
</Method>

<Method name="TestMultiDimension">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	// There doesn't seem to be any way of determining the subscripts of a local multi-dimensional array.
	set x = ""
	set x("tweets") = 7
	set x("twoots") = 9
	//w x("tweets"),!
	w "Length: ", $qlength("x(1)"),!
	w "Subscript: ", $qsubscript("x(1)",1), !
	w "is object: ", $isobject(x), ", class: '", $classname(x), "'", !
]]></Implementation>
</Method>

<Method name="TestDateAndTime">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	#dim d as %Date	// %Date stores the date as days since December 31, 1840, where so 1 is January 1, 1841
	#dim t as %Time	// %Time stores the time as seconds since midnight, including fractional seconds
	// Get the date/time in UTC ($HOROLOG gets it in local time without fractional seconds, $NOW() gets it with
	// fractional seconds and by default in local time, but optionally any time zone):
	#dim now as %String = $ZTIMESTAMP
	#dim sd = $piece(now, ",", 1)
	#dim st = $piece(now, ",", 2)
	set d = +sd
	set t = +st
	write ##class(%Date).LogicalToDisplay(d), !
	write ##class(%Time).LogicalToDisplay(t), !
	write $ztime(t, 1, 3, , 0), !
	write $zdate(d, 3), !
]]></Implementation>
</Method>
</Class>
</Export>
