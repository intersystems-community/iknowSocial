<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25">
<Class name="Util.Misc">
<Abstract>1</Abstract>
<TimeCreated>63524,64644.765551</TimeCreated>

<Method name="AddArrayToArray">
<Description>
Adds array A to array B</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>a:%ArrayOfDataTypes,b:%ArrayOfDataTypes</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set current = ""
	set status = $$$OK
	for {
		set current = a.Next(current)
		if (current = "") {
			return $$$OK
		}
		set status =  $$$ADDSC(status, b.SetAt(a.GetAt(current), current))
	}
	quit status
]]></Implementation>
</Method>

<Method name="ConvertVKDateToHorolog">
<Description>
Converts date in d[d].m[m].yyyy format to horolog.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>VKDate:%String</FormalSpec>
<ReturnType>%Date</ReturnType>
<Implementation><![CDATA[
	#dim date As %Date = ""
	if ($length(VKDate, ".") = 3) {
		if ($length($piece(VKDate, ".", 1)) = 1) {
			set VKDate = "0" _ VKDate
		}
		if ($length($piece(VKDate, ".", 2)) = 1) {
			set VKDate = $piece(VKDate, ".", 1) _ ".0" _ $piece(VKDate, ".", 2, 3)
		}
		set date = $zdateh($replace(VKDate, ".", "/"), 4)
	}
	quit date
]]></Implementation>
</Method>

<Method name="ConvertUnixTimeToHorolog">
<Description>
Given 'unixTime' in UNIX-time format saves corresponding value in horolog format to 'date' and 'time' variables. </Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>unixTime:%Integer,*date:%Integer,*time:%Numeric</FormalSpec>
<Implementation><![CDATA[
	set date = $normalize(unixTime / 86400, -1) + 47117	// get integer days part and adjust to Cache time
	set time = unixTime - ..ConvertHorologToUnixTime(date, 0)	// get remaining time in day in seconds
]]></Implementation>
</Method>

<Method name="ConvertHorologToUnixTime">
<Description>
Given 'date' and 'time' in horolog format returns corresponding UNIX-time value.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>date:%Integer,time:%Integer</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[	quit (date - 47117) * 86400 + time
]]></Implementation>
</Method>

<Method name="UrlEncode">
<Description>
Performs url-escaping.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>text:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	// Convert from Unicode to UTF-8 as explicit character sequences:
	set text = $zconvert(text, "O", "UTF8")
	// Encode using URL encoding:
	set text = $zconvert(text, "O", "URL")
	quit text
]]></Implementation>
</Method>

<Method name="IsInteger">
<Description>
Checks whereas passed string represents an integer.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>str:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[	quit ($isvalidnum(str) && (str # 1 = 0))
]]></Implementation>
</Method>

<Method name="IsValidDateAndTime">
<Description>
Checks whereas passed combination of 'date' and 'time' can actually represent some timestamp.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>date:%Date,time:%Time</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[	quit (##class(Util.Misc).IsInteger(date) && (date >= 0) && ##class(VKReader.Utils).IsInteger(time) && (time >= 0) && (time <= 86399))
]]></Implementation>
</Method>

<Method name="RunAllTests">
<Description>
Runs all tests across the project.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set status = ##class(Util.Requests.Tests.RequestMakerTests).Run()
	set status = $$$ADDSC(status, ##class(VKReader.Requests.Tests.APIPublicMethodsCallerTests).Run())
	set status = $$$ADDSC(status, ##class(VKReader.Data.Tests.PostTests).Run())
	set status = $$$ADDSC(status, ##class(VKReader.Data.Tests.UserTests).Run())
	quit status
]]></Implementation>
</Method>

<Method name="TestFunc">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set domId = ##class(%iKnow.Domain).GetOrCreateId("VKAPIDomain")
	if ##class(%iKnow.Configuration).Exists("VKAPIConfiguration") {
    	set cfg = ##class(%iKnow.Configuration).Open("VKAPIConfiguration") 
    } else {
		set cfg = ##class(%iKnow.Configuration).%New("VKAPIConfiguration", 1, $LB("ru"))
        do cfg.%Save() 
    }
    //set dom = ##class(%iKnow.Domain).OpenId(domId)
    //do dom.DropData()
	set lister = ##class(VKReader.Lister).%New(domId)
	do lister.SetConfig("VKAPIConfiguration")
	//set loader = ##class(%iKnow.Source.Loader).%New(domId)
	
	set status = lister.ProcessList("pizza", 100, 1)
	w "The lister status is ", $system.Status.DisplayError(status), !
	//set status = loader.ProcessBatch()
	//w "The loader status is ", $system.Status.DisplayError(status), !
	do ##class(%iKnow.Queries.SourceAPI).GetByDomain(.result, domId,,100)
	zw result
]]></Implementation>
</Method>

<Method name="Install">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	new $namespace
	set SSLConfigurationName = ##class(VKReader.Requests.RequestSender).%GetParameter("SSLConfigurationName")
	set $namespace = "%SYS"
	set status = $$$OK
	if (##class(Security.SSLConfigs).Exists(SSLConfigurationName) = 0) {
		set status = $$$ADDSC(status, ##class(Security.SSLConfigs).Create(SSLConfigurationName))
	}
	quit status
]]></Implementation>
</Method>
</Class>
</Export>
